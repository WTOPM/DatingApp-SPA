{"version":3,"sources":["/Users/annaodnostalko/Desktop/GIT/DatingApp/DatingApp-SPA/node_modules/@auth0/angular-jwt/fesm2015/auth0-angular-jwt.js"],"names":[],"mappings":"AAAA;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gHA+FE;;;;+BAI6B,AAE5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0GAsED;;;;;6BAK2B,AAE1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sJA6BD;;;;sCAIoC,AAEnC;;;;;;;;;;;;;;;;;;;;;kCAEW","file":"auth0-angular-jwt.js","sourcesContent":["import { __decorate, __param, __metadata } from 'tslib';\nimport { InjectionToken, Inject, Injectable, Optional, SkipSelf, NgModule } from '@angular/core';\nimport { mergeMap } from 'rxjs/operators';\nimport { parse } from 'url';\nimport { from } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n\n// tslint:disable:no-bitwise\nlet JwtHelperService = class JwtHelperService {\n    constructor(config = null) {\n        this.tokenGetter = config && config.tokenGetter || function () { };\n    }\n    urlBase64Decode(str) {\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\n        switch (output.length % 4) {\n            case 0: {\n                break;\n            }\n            case 2: {\n                output += '==';\n                break;\n            }\n            case 3: {\n                output += '=';\n                break;\n            }\n            default: {\n                throw new Error('Illegal base64url string!');\n            }\n        }\n        return this.b64DecodeUnicode(output);\n    }\n    // credits for decoder goes to https://github.com/atk\n    b64decode(str) {\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        let output = '';\n        str = String(str).replace(/=+$/, '');\n        if (str.length % 4 === 1) {\n            throw new Error('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\n        }\n        for (\n        // initialize result and counters\n        let bc = 0, bs, buffer, idx = 0; \n        // get next character\n        (buffer = str.charAt(idx++)); \n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n            ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4)\n            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n            : 0) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n        return output;\n    }\n    b64DecodeUnicode(str) {\n        return decodeURIComponent(Array.prototype.map\n            .call(this.b64decode(str), (c) => {\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n            .join(''));\n    }\n    decodeToken(token = this.tokenGetter()) {\n        if (!token || token === '') {\n            return null;\n        }\n        const parts = token.split('.');\n        if (parts.length !== 3) {\n            throw new Error('The inspected token doesn\\'t appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.');\n        }\n        const decoded = this.urlBase64Decode(parts[1]);\n        if (!decoded) {\n            throw new Error('Cannot decode the token.');\n        }\n        return JSON.parse(decoded);\n    }\n    getTokenExpirationDate(token = this.tokenGetter()) {\n        let decoded;\n        decoded = this.decodeToken(token);\n        if (!decoded || !decoded.hasOwnProperty('exp')) {\n            return null;\n        }\n        const date = new Date(0);\n        date.setUTCSeconds(decoded.exp);\n        return date;\n    }\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n        if (!token || token === '') {\n            return true;\n        }\n        const date = this.getTokenExpirationDate(token);\n        offsetSeconds = offsetSeconds || 0;\n        if (date === null) {\n            return false;\n        }\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n};\nJwtHelperService.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] }\n];\nJwtHelperService = __decorate([\n    Injectable(),\n    __param(0, Inject(JWT_OPTIONS)),\n    __metadata(\"design:paramtypes\", [Object])\n], JwtHelperService);\n\nlet JwtInterceptor = class JwtInterceptor {\n    constructor(config, jwtHelper) {\n        this.jwtHelper = jwtHelper;\n        this.tokenGetter = config.tokenGetter;\n        this.headerName = config.headerName || 'Authorization';\n        this.authScheme =\n            config.authScheme || config.authScheme === ''\n                ? config.authScheme\n                : 'Bearer ';\n        this.whitelistedDomains = config.whitelistedDomains || [];\n        this.blacklistedRoutes = config.blacklistedRoutes || [];\n        this.throwNoTokenError = config.throwNoTokenError || false;\n        this.skipWhenExpired = config.skipWhenExpired;\n    }\n    isWhitelistedDomain(request) {\n        const requestUrl = parse(request.url, false, true);\n        return (requestUrl.host === null ||\n            this.whitelistedDomains.findIndex(domain => typeof domain === 'string'\n                ? domain === requestUrl.host\n                : domain instanceof RegExp\n                    ? domain.test(requestUrl.host)\n                    : false) > -1);\n    }\n    isBlacklistedRoute(request) {\n        const url = request.url;\n        return (this.blacklistedRoutes.findIndex(route => typeof route === 'string'\n            ? route === url\n            : route instanceof RegExp\n                ? route.test(url)\n                : false) > -1);\n    }\n    handleInterception(token, request, next) {\n        let tokenIsExpired = false;\n        if (!token && this.throwNoTokenError) {\n            throw new Error('Could not get token from tokenGetter function.');\n        }\n        if (this.skipWhenExpired) {\n            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n        }\n        if (token && tokenIsExpired && this.skipWhenExpired) {\n            request = request.clone();\n        }\n        else if (token) {\n            request = request.clone({\n                setHeaders: {\n                    [this.headerName]: `${this.authScheme}${token}`\n                }\n            });\n        }\n        return next.handle(request);\n    }\n    intercept(request, next) {\n        if (!this.isWhitelistedDomain(request) ||\n            this.isBlacklistedRoute(request)) {\n            return next.handle(request);\n        }\n        const token = this.tokenGetter();\n        if (token instanceof Promise) {\n            return from(token).pipe(mergeMap((asyncToken) => {\n                return this.handleInterception(asyncToken, request, next);\n            }));\n        }\n        else {\n            return this.handleInterception(token, request, next);\n        }\n    }\n};\nJwtInterceptor.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] },\n    { type: JwtHelperService }\n];\nJwtInterceptor = __decorate([\n    Injectable(),\n    __param(0, Inject(JWT_OPTIONS)),\n    __metadata(\"design:paramtypes\", [Object, JwtHelperService])\n], JwtInterceptor);\n\nvar JwtModule_1;\nlet JwtModule = JwtModule_1 = class JwtModule {\n    constructor(parentModule) {\n        if (parentModule) {\n            throw new Error('JwtModule is already loaded. It should only be imported in your application\\'s main module.');\n        }\n    }\n    static forRoot(options) {\n        return {\n            ngModule: JwtModule_1,\n            providers: [\n                {\n                    provide: HTTP_INTERCEPTORS,\n                    useClass: JwtInterceptor,\n                    multi: true\n                },\n                options.jwtOptionsProvider ||\n                    {\n                        provide: JWT_OPTIONS,\n                        useValue: options.config\n                    },\n                JwtHelperService\n            ]\n        };\n    }\n};\nJwtModule.ctorParameters = () => [\n    { type: JwtModule, decorators: [{ type: Optional }, { type: SkipSelf }] }\n];\nJwtModule = JwtModule_1 = __decorate([\n    NgModule(),\n    __param(0, Optional()), __param(0, SkipSelf()),\n    __metadata(\"design:paramtypes\", [JwtModule])\n], JwtModule);\n\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };\n"]}